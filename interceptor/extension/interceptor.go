package rkginextension

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/rookie-ninja/rk-common/common"
	"github.com/rookie-ninja/rk-entry/entry"
	"github.com/rookie-ninja/rk-gin/interceptor/context"
	"strings"
	"time"
)

// Add common headers as extension style in http response.
// The key is defined as bellow:
// 1: X-<Prefix>-Request-Id: Request id generated by interceptor.
// 2: X-<Prefix>-Location: A valid URI.
// 3: X-<Prefix>-Locale: Locale of current service.
// 4: X-<Prefix-App: Application name.
// 5: X-<Prefix>-App-Version: Version of application.
// 6: X-<Prefix>-App-Unix-Time: Unix time of current application.
// 7: X-<Prefix>-Request-Received-Time: Time of current request received by application.
func ExtensionInterceptor(opts ...Option) gin.HandlerFunc {
	set := &optionSet{
		EntryName: rkginctx.RkEntryNameValue,
		EntryType: rkginctx.RkEntryTypeValue,
		Prefix:    "rk",
	}

	for i := range opts {
		opts[i](set)
	}

	if _, ok := optionsMap[set.EntryName]; !ok {
		optionsMap[set.EntryName] = set
	}

	var (
		requestIdKey = fmt.Sprintf("X-%s-Request-Id", set.Prefix)
		locationKey  = fmt.Sprintf("X-%s-Location", set.Prefix)

		localeKey   = fmt.Sprintf("X-%s-Locale", set.Prefix)
		localeValue = strings.Join([]string{
			rkginctx.Realm.String,
			rkginctx.Region.String,
			rkginctx.AZ.String,
			rkginctx.Domain.String,
		}, "::")

		appNameKey   = fmt.Sprintf("X-%s-App-Name", set.Prefix)
		appNameValue = rkentry.GlobalAppCtx.GetAppInfoEntry().AppName

		appVersionKey   = fmt.Sprintf("X-%s-App-Version", set.Prefix)
		appVersionValue = rkentry.GlobalAppCtx.GetAppInfoEntry().Version

		appUnixTimeKey  = fmt.Sprintf("X-%s-App-Unix-Time", set.Prefix)
		receivedTimeKey = fmt.Sprintf("X-%s-Request-Received-Time", set.Prefix)
	)

	return func(ctx *gin.Context) {
		ctx.Header(requestIdKey, rkcommon.GenerateRequestId())
		ctx.Header(localeKey, localeValue)
		ctx.Header(appNameKey, appNameValue)
		ctx.Header(appVersionKey, appVersionValue)

		now := time.Now()
		ctx.Header(appUnixTimeKey, now.Format(time.RFC3339Nano))
		ctx.Header(receivedTimeKey, now.Format(time.RFC3339Nano))

		// construct location
		scheme := "http"
		if ctx.Request.TLS != nil {
			scheme = "https"
		}

		host := ctx.Request.Host
		if len(host) < 1 {
			host = rkginctx.LocalIp.String
		}

		ctx.Header(locationKey, fmt.Sprintf("%s://%s%s", scheme, ctx.Request.Host, ctx.Request.RequestURI))

		ctx.Next()
	}
}

func getOptionSet(ctx *gin.Context) *optionSet {
	if ctx == nil {
		return nil
	}

	entryName := ctx.GetString(rkginctx.RkEntryNameKey)
	return optionsMap[entryName]
}

var optionsMap = make(map[string]*optionSet)

// options which is used while initializing extension interceptor
type optionSet struct {
	EntryName string
	EntryType string
	Prefix    string
}

type Option func(*optionSet)

func WithEntryNameAndType(entryName, entryType string) Option {
	return func(opt *optionSet) {
		opt.EntryName = entryName
		opt.EntryType = entryType
	}
}

func WithPrefix(prefix string) Option {
	return func(opt *optionSet) {
		opt.Prefix = prefix
	}
}
